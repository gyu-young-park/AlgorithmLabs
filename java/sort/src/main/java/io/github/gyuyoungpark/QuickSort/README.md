# QuickSort
쿽정렬의 가장 기본 로직은 배열의 원소가 정렬될 경우, 배열 내에 '내 자리'가 있다는 것이다. 이 자리는 내 왼쪽은 나보다 작거나 같고, 오른쪽은 나보다 크거나 같다는 것이다. 이러한 원리 입각해서, 쿽정렬은 배열의 첫번째 값을 pivot으로 선정하고, 두번째 값이 left, 맨 끝이 right로 해서 pivot보다 큰 left값은 pivot보다 작은 right값과 계속 바꿔주는 알고리즘이다.

1. 배열의 첫번째 값을 pivot으로 잡는다.
2. 배열의 두번째 값을 left, 맨 마지막 값을 right로 잡는다.
3. left에서 계속 오른쪽으로 움직이다가, pivot보다 큰 값이 있다면 이는 pivot보다 오른쪽에 있어야 하는 값이기 때문에 멈춘다.
4. right에서 계속 왼쪽으로 움직이다가, pivot보다 작은 값이 있다면 이는 pivot보다 왼쪽에 있어야 하는 값이기 때문에 멈춘다.
5. left와 right의 값을 바꾼다. -> exception: 단, left가 right보다 작을 때만 바꾼다. 이는 엇갈린 상황에서는 바로 swap이 이루어지면 안되기 때문에 상황을 나눈 것이다.
6. 이 과정을 반복하는데, right가 left를 넘어설 때까지 반복한다.
7. right와 left가 엇갈리게 되면 right의 값은 이미 left가 검사한 값이기 때문에 pivot보다 작고, 그 오른쪽은 모두 right가 검사했기 때문에 pivot보다 크다.
8. 따라서 right와 pivot 값을 바꾸도록 하면, 그 자리가 pivot이 정렬되었을 때의 자리이다.
9. 이제 pivot은 정렬되었으니 pivot을 기점으로 절반을 나누어서 퀵정렬을 시킨다. 즉, 분할-정복이다.

절반으로 분할하기 때문에 O(logn)번의 과정이 있지만 매번 최대 n개의 비교가 있어서 O(nlogn)이 평균적으로 나온다. 만약 정렬된 상태였다면 pivot을 기점으로 절반이 나누어지지 않기 때문에 O(n^2)이 나온다.

이러한 문제를 해결하기 위해서 중간값과 맨 처음값을 바꾸도록 하는 방법이 있다. 셔플을 통해서 문제를 해결하는 방법이다.